//! LTL Safety Monitor - Runtime verification
//!
//! # Sati (Chánh Niệm) - The Meta-Observer
//!
//! This module implements the "Sati" consciousness aspect - the mindful observer
//! that watches ALL events flowing through the system and ensures safety.
//!
//! ## B.ONE V3: Luật Chánh Niệm
//! > "If it's not observed by Sati, it didn't happen (no Karma)."
//!
//! The SafetyMonitor serves dual roles:
//! 1. **LTL Runtime Verification** - Checks temporal logic properties
//! 2. **Flow Observer (Sati)** - Watches all FlowEvents for anomalies
//!
//! Reference: SafetyMonitor.ts (~300 lines)

use std::sync::Arc;
use crate::universal_flow::{FlowEvent, SkandhaStage, VedanaType, FlowEventId};
use crate::philosophical_state::PhilosophicalState;

/// Safety violation record
#[derive(Debug, Clone)]
pub struct SafetyViolation {
    pub timestamp: u64,
    pub property_name: String,
    pub description: String,
    pub severity: Severity,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Severity {
    Critical,
    Warning,
}

/// Runtime state snapshot
#[derive(Debug, Clone)]
pub struct RuntimeState {
    pub tempo_scale: f32,
    pub status: String,
    pub session_duration: f32,
    pub prediction_error: f32,
    pub last_update_timestamp: u64,
}

/// Safety property (LTL formula)
pub struct SafetyProperty {
    pub name: &'static str,
    pub description: &'static str,
    pub predicate: Arc<dyn Fn(&RuntimeState) -> bool + Send + Sync>,
}

impl SafetyProperty {
    pub fn new(
        name: &'static str,
        description: &'static str,
        predicate: impl Fn(&RuntimeState) -> bool + Send + Sync + 'static,
    ) -> Self {
        Self {
            name,
            description,
            predicate: Arc::new(predicate),
        }
    }
}

// ============================================================================
// SATI OBSERVER TYPES (B.ONE V3: Meta-Observer)
// ============================================================================

/// Alert generated by Sati when anomalies are detected.
#[derive(Debug, Clone)]
pub struct SatiAlert {
    /// Timestamp when alert was generated
    pub timestamp_us: i64,
    /// Type of alert
    pub alert_type: SatiAlertType,
    /// Human-readable description
    pub description: String,
    /// Severity level
    pub severity: Severity,
    /// Related FlowEvent ID (if applicable)
    pub related_event_id: Option<FlowEventId>,
}

/// Types of alerts Sati can generate.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum SatiAlertType {
    /// Philosophical state transition detected
    StateTransition,
    /// High karma imbalance detected
    KarmaImbalance,
    /// Too many Dukkha events in sequence
    DukkhaSpike,
    /// Anomalous event pattern detected
    AnomalousPattern,
    /// Pipeline stage skipped or out of order
    PipelineAnomaly,
    /// Long gap between events (system may be stalled)
    EventGap,
    /// Free energy spike (high surprise)
    FreeEnergySpike,
}

/// Statistics tracked by Sati observer.
#[derive(Debug, Clone, Default)]
pub struct SatiStats {
    /// Total events observed
    pub total_events: u64,
    /// Events by Skandha stage
    pub events_by_stage: [u64; 6],
    /// Events by Vedana type
    pub events_by_vedana: [u64; 3],
    /// Running karma balance
    pub karma_balance: f32,
    /// Count of state transitions
    pub state_transitions: u64,
    /// Last observed philosophical state
    pub last_philosophical_state: Option<PhilosophicalState>,
    /// Last event timestamp
    pub last_event_ts_us: i64,
    /// Consecutive Dukkha count (for spike detection)
    pub consecutive_dukkha: u32,
    /// Maximum observed free energy
    pub max_free_energy: f32,
}

/// Safety Monitor
///
/// # Dual Role (B.ONE V3)
/// 1. **LTL Verification**: Checks runtime safety properties
/// 2. **Sati Observer**: Watches ALL FlowEvents for anomalies
pub struct SafetyMonitor {
    // === LTL Verification ===
    properties: Vec<SafetyProperty>,
    violations: Vec<SafetyViolation>,
    max_violations: usize,

    // === Sati Observer (B.ONE V3) ===
    /// Statistics about observed events
    pub sati_stats: SatiStats,
    /// Alerts generated by Sati
    sati_alerts: Vec<SatiAlert>,
    /// Maximum alerts to retain
    max_alerts: usize,
    /// Sati observation enabled
    sati_enabled: bool,
    /// Threshold for karma imbalance alert
    karma_imbalance_threshold: f32,
    /// Threshold for consecutive Dukkha spike alert
    dukkha_spike_threshold: u32,
    /// Threshold for event gap alert (microseconds)
    event_gap_threshold_us: i64,
    /// Threshold for free energy spike alert
    free_energy_spike_threshold: f32,
}

impl SafetyMonitor {
    pub fn new() -> Self {
        let mut properties = Vec::new();

        // Property 1: Tempo bounds [0.8, 1.4]
        properties.push(SafetyProperty::new(
            "tempo_bounds",
            "Tempo must stay within [0.8, 1.4]",
            |state| state.tempo_scale >= 0.8 && state.tempo_scale <= 1.4,
        ));

        // Property 2: Safety lock immutable
        properties.push(SafetyProperty::new(
            "safety_lock_immutable",
            "Once in SAFETY_LOCK, cannot start new session",
            |state| state.status != "SAFETY_LOCK" || state.session_duration == 0.0,
        ));

        // Property 3: Panic halt
        properties.push(SafetyProperty::new(
            "panic_halt",
            "High prediction error must trigger halt",
            |state| {
                if state.prediction_error > 0.95 && state.session_duration > 10.0 {
                    state.status == "HALTED" || state.status == "SAFETY_LOCK"
                } else {
                    true
                }
            },
        ));

        Self {
            properties,
            violations: Vec::new(),
            max_violations: 100,
            // Sati Observer initialization
            sati_stats: SatiStats::default(),
            sati_alerts: Vec::new(),
            max_alerts: 50,
            sati_enabled: true,
            karma_imbalance_threshold: 5.0,
            dukkha_spike_threshold: 5,
            event_gap_threshold_us: 10_000_000, // 10 seconds
            free_energy_spike_threshold: 0.8,
        }
    }

    /// Check if state satisfies all safety properties
    pub fn check(&mut self, state: &RuntimeState) -> Result<(), Vec<SafetyViolation>> {
        let mut violations = Vec::new();

        for prop in &self.properties {
            if !(prop.predicate)(state) {
                let violation = SafetyViolation {
                    timestamp: state.last_update_timestamp,
                    property_name: prop.name.to_string(),
                    description: prop.description.to_string(),
                    severity: Severity::Critical,
                };

                violations.push(violation);
            }
        }

        // Record all violations after iteration
        for v in &violations {
            self.record_violation(v.clone());
        }

        if violations.is_empty() {
            Ok(())
        } else {
            Err(violations)
        }
    }

    /// Shield (correct) a tempo value to be safe
    pub fn shield_tempo(&self, tempo: f32) -> f32 {
        tempo.clamp(0.8, 1.4)
    }

    fn record_violation(&mut self, violation: SafetyViolation) {
        self.violations.push(violation);
        if self.violations.len() > self.max_violations {
            self.violations.remove(0);
        }
    }

    pub fn get_violations(&self) -> &[SafetyViolation] {
        &self.violations
    }

    pub fn clear_violations(&mut self) {
        self.violations.clear();
    }

    // =========================================================================
    // SATI OBSERVER METHODS (B.ONE V3: Luật Chánh Niệm)
    // =========================================================================

    /// Observe a FlowEvent and update statistics.
    ///
    /// # B.ONE V3: Luật Chánh Niệm
    /// This is the core Sati function. Every FlowEvent should pass through here
    /// for total observability. If an event is not observed, it has no Karma.
    ///
    /// # Returns
    /// Any alerts generated by observing this event.
    pub fn observe_flow(&mut self, event: &FlowEvent) -> Vec<SatiAlert> {
        if !self.sati_enabled {
            return Vec::new();
        }

        let mut alerts = Vec::new();

        // 1. Update basic statistics
        self.sati_stats.total_events += 1;
        self.sati_stats.events_by_stage[event.skandha_stage as usize] += 1;

        // 2. Check for event gap (system stall)
        if self.sati_stats.last_event_ts_us > 0 {
            let gap = event.timestamp_us - self.sati_stats.last_event_ts_us;
            if gap > self.event_gap_threshold_us {
                alerts.push(SatiAlert {
                    timestamp_us: event.timestamp_us,
                    alert_type: SatiAlertType::EventGap,
                    description: format!(
                        "Event gap detected: {}ms between events",
                        gap / 1000
                    ),
                    severity: Severity::Warning,
                    related_event_id: Some(event.id),
                });
            }
        }
        self.sati_stats.last_event_ts_us = event.timestamp_us;

        // 3. Track Vedana (feeling) statistics
        if let Some(vedana_type) = event.enrichment.vedana_type {
            match vedana_type {
                VedanaType::Sukha => {
                    self.sati_stats.events_by_vedana[0] += 1;
                    self.sati_stats.consecutive_dukkha = 0;
                }
                VedanaType::Dukkha => {
                    self.sati_stats.events_by_vedana[1] += 1;
                    self.sati_stats.consecutive_dukkha += 1;

                    // Check for Dukkha spike
                    if self.sati_stats.consecutive_dukkha >= self.dukkha_spike_threshold {
                        alerts.push(SatiAlert {
                            timestamp_us: event.timestamp_us,
                            alert_type: SatiAlertType::DukkhaSpike,
                            description: format!(
                                "Dukkha spike: {} consecutive unpleasant events",
                                self.sati_stats.consecutive_dukkha
                            ),
                            severity: Severity::Warning,
                            related_event_id: Some(event.id),
                        });
                    }
                }
                VedanaType::Upekkha => {
                    self.sati_stats.events_by_vedana[2] += 1;
                    self.sati_stats.consecutive_dukkha = 0;
                }
            }
        }

        // 4. Track karma balance
        if let Some(karma_weight) = event.enrichment.karma_weight {
            self.sati_stats.karma_balance += karma_weight;

            // Check for karma imbalance
            if self.sati_stats.karma_balance.abs() > self.karma_imbalance_threshold {
                alerts.push(SatiAlert {
                    timestamp_us: event.timestamp_us,
                    alert_type: SatiAlertType::KarmaImbalance,
                    description: format!(
                        "Karma imbalance: balance = {:.2}",
                        self.sati_stats.karma_balance
                    ),
                    severity: if self.sati_stats.karma_balance < 0.0 {
                        Severity::Warning
                    } else {
                        Severity::Warning
                    },
                    related_event_id: Some(event.id),
                });
            }
        }

        // 5. Track philosophical state transitions
        if let Some(new_state) = event.enrichment.philosophical_state {
            if let Some(old_state) = self.sati_stats.last_philosophical_state {
                if new_state != old_state {
                    self.sati_stats.state_transitions += 1;
                    alerts.push(SatiAlert {
                        timestamp_us: event.timestamp_us,
                        alert_type: SatiAlertType::StateTransition,
                        description: format!(
                            "State transition: {} -> {}",
                            old_state.vietnamese_name(),
                            new_state.vietnamese_name()
                        ),
                        severity: Severity::Warning,
                        related_event_id: Some(event.id),
                    });
                }
            }
            self.sati_stats.last_philosophical_state = Some(new_state);
        }

        // 6. Store alerts
        for alert in &alerts {
            self.record_alert(alert.clone());
        }

        alerts
    }

    /// Observe free energy value for spike detection.
    ///
    /// Call this separately from observe_flow when processing FEP updates.
    pub fn observe_free_energy(&mut self, free_energy: f32, timestamp_us: i64) -> Option<SatiAlert> {
        if !self.sati_enabled {
            return None;
        }

        // Update max
        if free_energy > self.sati_stats.max_free_energy {
            self.sati_stats.max_free_energy = free_energy;
        }

        // Check for spike
        if free_energy > self.free_energy_spike_threshold {
            let alert = SatiAlert {
                timestamp_us,
                alert_type: SatiAlertType::FreeEnergySpike,
                description: format!(
                    "Free energy spike: {:.3} (threshold: {:.3})",
                    free_energy, self.free_energy_spike_threshold
                ),
                severity: Severity::Warning,
                related_event_id: None,
            };
            self.record_alert(alert.clone());
            return Some(alert);
        }

        None
    }

    /// Record a Sati alert.
    fn record_alert(&mut self, alert: SatiAlert) {
        self.sati_alerts.push(alert);
        if self.sati_alerts.len() > self.max_alerts {
            self.sati_alerts.remove(0);
        }
    }

    /// Get all Sati alerts.
    pub fn get_sati_alerts(&self) -> &[SatiAlert] {
        &self.sati_alerts
    }

    /// Clear Sati alerts.
    pub fn clear_sati_alerts(&mut self) {
        self.sati_alerts.clear();
    }

    /// Get Sati statistics.
    pub fn get_sati_stats(&self) -> &SatiStats {
        &self.sati_stats
    }

    /// Reset Sati statistics.
    pub fn reset_sati_stats(&mut self) {
        self.sati_stats = SatiStats::default();
    }

    /// Enable/disable Sati observer.
    pub fn set_sati_enabled(&mut self, enabled: bool) {
        self.sati_enabled = enabled;
    }

    /// Check if Sati observer is enabled.
    pub fn is_sati_enabled(&self) -> bool {
        self.sati_enabled
    }

    /// Configure Sati thresholds.
    pub fn configure_sati(
        &mut self,
        karma_threshold: Option<f32>,
        dukkha_threshold: Option<u32>,
        event_gap_us: Option<i64>,
        free_energy_threshold: Option<f32>,
    ) {
        if let Some(t) = karma_threshold {
            self.karma_imbalance_threshold = t;
        }
        if let Some(t) = dukkha_threshold {
            self.dukkha_spike_threshold = t;
        }
        if let Some(t) = event_gap_us {
            self.event_gap_threshold_us = t;
        }
        if let Some(t) = free_energy_threshold {
            self.free_energy_spike_threshold = t;
        }
    }

    /// Get a summary of the current Sati state for logging.
    pub fn sati_summary(&self) -> String {
        let stats = &self.sati_stats;
        format!(
            "Sati[events={}, karma={:.2}, transitions={}, dukkha_streak={}, alerts={}]",
            stats.total_events,
            stats.karma_balance,
            stats.state_transitions,
            stats.consecutive_dukkha,
            self.sati_alerts.len()
        )
    }
}

impl Default for SafetyMonitor {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tempo_bounds_valid() {
        let mut monitor = SafetyMonitor::new();
        let state = RuntimeState {
            tempo_scale: 1.0,
            status: "RUNNING".into(),
            session_duration: 30.0,
            prediction_error: 0.1,
            last_update_timestamp: 1000,
        };

        assert!(monitor.check(&state).is_ok());
    }

    #[test]
    fn test_tempo_bounds_violation() {
        let mut monitor = SafetyMonitor::new();
        let state = RuntimeState {
            tempo_scale: 2.0, // Out of bounds!
            status: "RUNNING".into(),
            session_duration: 30.0,
            prediction_error: 0.1,
            last_update_timestamp: 1000,
        };

        let result = monitor.check(&state);
        assert!(result.is_err());

        let violations = result.unwrap_err();
        assert_eq!(violations.len(), 1);
        assert_eq!(violations[0].property_name, "tempo_bounds");
    }

    #[test]
    fn test_shield_tempo() {
        let monitor = SafetyMonitor::new();

        assert_eq!(monitor.shield_tempo(0.5), 0.8);
        assert_eq!(monitor.shield_tempo(1.0), 1.0);
        assert_eq!(monitor.shield_tempo(2.0), 1.4);
    }

    #[test]
    fn test_panic_halt() {
        let mut monitor = SafetyMonitor::new();

        // High error but session too short - should pass
        let state1 = RuntimeState {
            tempo_scale: 1.0,
            status: "RUNNING".into(),
            session_duration: 5.0,
            prediction_error: 0.96,
            last_update_timestamp: 1000,
        };
        assert!(monitor.check(&state1).is_ok());

        // High error, long session, still running - should fail
        let state2 = RuntimeState {
            tempo_scale: 1.0,
            status: "RUNNING".into(),
            session_duration: 15.0,
            prediction_error: 0.96,
            last_update_timestamp: 2000,
        };
        assert!(monitor.check(&state2).is_err());

        // High error, long session, halted - should pass
        let state3 = RuntimeState {
            tempo_scale: 1.0,
            status: "HALTED".into(),
            session_duration: 15.0,
            prediction_error: 0.96,
            last_update_timestamp: 3000,
        };
        assert!(monitor.check(&state3).is_ok());
    }

    // =========================================================================
    // SATI OBSERVER TESTS
    // =========================================================================

    #[test]
    fn test_sati_basic_observation() {
        use crate::domain::SessionId;
        use crate::universal_flow::{FlowEnrichment, FlowPayload};
        use crate::skandha::SensorInput;

        let mut monitor = SafetyMonitor::new();
        assert!(monitor.is_sati_enabled());
        assert_eq!(monitor.sati_stats.total_events, 0);

        // Create a test FlowEvent
        let event = FlowEvent {
            id: FlowEventId(1),
            session_id: SessionId::default(),
            timestamp_us: 1000,
            payload: FlowPayload::RawSensor(SensorInput::default()),
            skandha_stage: SkandhaStage::Rupa,
            enrichment: FlowEnrichment::default(),
            lineage: vec![],
        };

        let alerts = monitor.observe_flow(&event);
        assert!(alerts.is_empty()); // No alerts for first event
        assert_eq!(monitor.sati_stats.total_events, 1);
        assert_eq!(monitor.sati_stats.events_by_stage[0], 1); // Rupa = 0
    }

    #[test]
    fn test_sati_dukkha_spike_detection() {
        use crate::domain::SessionId;
        use crate::universal_flow::{FlowEnrichment, FlowPayload};
        use crate::skandha::SensorInput;

        let mut monitor = SafetyMonitor::new();
        monitor.configure_sati(None, Some(3), None, None); // Lower threshold for testing

        // Generate 3 consecutive Dukkha events
        for i in 0..4 {
            let event = FlowEvent {
                id: FlowEventId(i as u64),
                session_id: SessionId::default(),
                timestamp_us: i as i64 * 1000,
                payload: FlowPayload::RawSensor(SensorInput::default()),
                skandha_stage: SkandhaStage::Vedana,
                enrichment: FlowEnrichment {
                    vedana_type: Some(VedanaType::Dukkha),
                    karma_weight: Some(-0.5),
                    ..Default::default()
                },
                lineage: vec![],
            };

            let alerts = monitor.observe_flow(&event);

            if i >= 2 {
                // After 3 Dukkha events, should have spike alert
                assert!(
                    alerts.iter().any(|a| a.alert_type == SatiAlertType::DukkhaSpike),
                    "Expected DukkhaSpike alert at event {}", i
                );
            }
        }
    }

    #[test]
    fn test_sati_free_energy_spike() {
        let mut monitor = SafetyMonitor::new();
        monitor.configure_sati(None, None, None, Some(0.5)); // Lower threshold

        // Low free energy - no alert
        let alert1 = monitor.observe_free_energy(0.3, 1000);
        assert!(alert1.is_none());

        // High free energy - alert
        let alert2 = monitor.observe_free_energy(0.7, 2000);
        assert!(alert2.is_some());
        assert_eq!(alert2.unwrap().alert_type, SatiAlertType::FreeEnergySpike);
    }

    #[test]
    fn test_sati_summary() {
        let monitor = SafetyMonitor::new();
        let summary = monitor.sati_summary();
        assert!(summary.contains("Sati"));
        assert!(summary.contains("events=0"));
    }
}
